<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>CaaS Node/Client-Side API (hc-caas-api)</h1>
<h2>Overview</h2>
<p>This is the Node.js client-side API for the Communicator as a Service (CaaS) project. It is used to communicate with a CaaS Server Instance. You can use it to convert models to SC/SCZ files, generate images or generate STEP/PDF and other formats. You can either connect to your own instance of CaaS or to the official CaaS Server API available at <a href="https://caas.techsoft3d.com">https://caas.techsoft3d.com</a>.</p>
<h2>Installation</h2>
<h3>Server-Side</h3>
<p>To install the API, run the following command:</p>
<pre class="prettyprint source"><code>npm install hc-caas-api
</code></pre>
<h3>Client-Side</h3>
<p>Copy the caas.min.js file from the dist folder into your project.</p>
<h2>Initialization and Authentication</h2>
<p>To initialize the library simply provide the URL of the CaaS server instance you wish to connect to.</p>
<p>To use the API with the official CaaS server, you will need to obtain an API key. You can request an account at <a href="https://caas-admin.techsoft3d.com">https://caas-admin.techsoft3d.com</a>. Once you have an account, you can generate an API key from the &quot;API Keys&quot; tab. You will need to provide this key when initializing this library. If you are using your own instance of CaaS, authentication is an optional feature.</p>
<p><strong>Remember that your API key is secret and should not be shared with others or exposed in your client-side code in production!</strong></p>
<pre class="prettyprint source"><code> caasClient.init('https://caas.techsoft3d.com',{accessKey :&quot;ENTER YOUR ACCESS KEY HERE&quot;});   
</code></pre>
<h2>Example Usage</h2>
<h3>Simple Conversion</h3>
<p>In this example a file is uploaded to the CaaS server from the file system, converted to SC/SCZ and PNG with the default settings. The function <code>waitUntilConverted</code> is used to wait until the conversion is complete. The SCS file is then downloaded to the file system after the conversion is complete.</p>
<pre class="prettyprint source"><code>let info = await caasClient.uploadModelFromFile(&quot;./testfiles/bnc.hsf&quot;);
await caasClient.waitUntilConverted(info.itemid);
await caasClient.getFileByType(info.itemid, &quot;scs&quot;, &quot;./output/&quot; + &quot;bnc.hsf.scs&quot;);
</code></pre>
<h3>Conversion with custom polling</h3>
<p>In this slightly more elaborate example two files are uploaded to CaaS for conversion and a custom polling mechanism is used to check for completed conversions</p>
<pre class="prettyprint source"><code>let pendingModels = [];
pendingModels.push((await caasClient.uploadModelFromFile(&quot;./testfiles/bnc.hsf&quot;)).itemid);
pendingModels.push((await caasClient.uploadModelFromFile(&quot;./testfiles/axe.CATPART&quot;)).itemid);

let intervalid = setInterval(async () => {
    if (!pendingModels.length) {
        clearInterval(intervalid);
        return;
    }
    let res = await caasClient.getModelData(pendingModels);
    if (pendingModels.length == 1) {
        res = [res];
    }
    console.log(pendingModels + &quot; &quot; + res.length);
    for (let i=0; i&lt;res.length; i++) {
        console.log(res[i].name + &quot;:&quot; + res[i].conversionState);            
        if (res[i].conversionState != &quot;PENDING&quot;) {              
            pendingModels.splice(i, 1);
            caasClient.getFileByType(res[i].storageID, &quot;scs&quot;, &quot;./output/&quot; + res[i].name + &quot;.scs&quot;);
        }
    }            
}, 1000);
</code></pre>
<h3>Conversions with Webhooks</h3>
<p>Instead of polling to wait for completed conversions a more elegant solution is to use webhooks. If a webhook is passed during intialization, the CaaS server will send a POST request to the webhook URL when a conversion is complete. The POST request will contain a JSON object with information about the converted model.</p>
<pre class="prettyprint source"><code>caasClient.init('http://localhost:3001', {webhook:'http://localhost:3000/webhook'});

await caasClient.uploadModelFromFile(&quot;./testfiles/bnc.hsf&quot;);
await caasClient.uploadModelFromFile(&quot;./testfiles/axe.CATPart&quot;);

app.use(express.json());
app.post('/webhook', async (req, res) => {
    console.log(&quot;Received webhook for &quot; + req.body.name + &quot;.scs&quot;) 
    await caasClient.getFileByType(req.body.id, &quot;scs&quot;, &quot;./output/&quot; + req.body.name + &quot;.scs&quot;);      
    res.sendStatus(200);
});

app.listen(3000);
</code></pre>
<h3>Custom Conversion Settings</h3>
<p>It is possible to override the default conversion settings of CaaS and instead provide your own command line. In this case, we are exporting a STEP file instead of generating SCS/SCZ/PNG files.</p>
<pre class="prettyprint source"><code>let info = await caasClient.uploadModelFromFile(&quot;./testfiles/axe.CATPART&quot;,null,{conversionCommandLine:[&quot;--output_step&quot;,&quot;&quot;]});
await caasClient.waitUntilConverted(info.itemid);
await caasClient.getFileByType(info.itemid, &quot;step&quot;, &quot;./output/&quot; + &quot;axe.step&quot;);   
</code></pre>
<h3>Adding Conversion Settings</h3>
<p>It is also possible to add additional command line options by specifying a <code>*</code> as the first commnand line argument. In this example we also pass in a custom XML settings file that will be used during conversion.</p>
<pre class="prettyprint source"><code>let info = await caasClient.uploadModelFromFiles([&quot;./testfiles/axe.CATPART&quot;, &quot;././testfiles/he_settings.xml&quot;],&quot;axe.CATPART&quot;, {conversionCommandLine:[&quot;*&quot;,&quot;--xml_settings&quot;,&quot;he_settings.xml&quot;]});
await caasClient.waitUntilConverted(info.data.itemid);
let modelData = await caasClient.getModelData(info.data.itemid);
console.log(modelData);
</code></pre>
<h3>SCS Viewing via download token</h3>
<p>The simplest way to view a previous converted SCS file via CaaS is to use the <code>getDownloadToken</code> function. This function returns a unique, time-limited token that can be used to download the SCS file directly from the backend-storage of the CaaS server. However, this functionality is only availabe if S3 or Azure Blob Storage is used as the backend storage or you are using the official CaaS server.</p>
<pre class="prettyprint source"><code>// In production this call should be performed server-side
let res = await caasClient.getDownloadToken(&quot;ID-OF-MODEL-TO-LOAD&quot;,&quot;scs&quot;);

await hwv.model.loadSubtreeFromScsFile(hwv.model.getRootNode(), res.token);
</code></pre>
<h3>SCS Viewing with Buffer</h3>
<p>You can also access scs files and other files with a call to <code>getFileByType</code> with the itemid of the model. In production you would do this in your server application. This buffer can then be send to the webviewer client. In this example we are using express to serve the buffer to the client.</p>
<p>Server:</p>
<pre class="prettyprint source"><code>let result =  await caasClient.getFileByType(&quot;ID-OF-MODEL-TO-LOAD&quot;,&quot;scs&quot;); 
if (result.ERROR) {
    res.status(404).json(result);
}
else {
    res.send(Buffer.from(result));
}
</code></pre>
<p>Client:</p>
<pre class="prettyprint source"><code>// Get the SCS file from your server (typical via a fetch request to your server)
let ab = await res.arrayBuffer();
await hwv.model.loadSubtreeFromScsBuffer(hwv.model.getRootNode(), new Uint8Array(ab));
</code></pre>
<p>Client Only:<br>
For testing purposes you can also get the SCS file directly from the CaaS server in the web client using the client-side version of the API:</p>
<pre class="prettyprint source"><code>let buffer =  await caasClient.getFileByType(&quot;ID-OF-MODEL-TO-LOAD&quot;,&quot;scs&quot;); 
if (!buffer.ERROR) {
   await hwv.model.loadSubtreeFromScsBuffer(hwv.model.getRootNode(), new Uint8Array(buffer));
}

</code></pre>
<h3>Streaming</h3>
<p>To utilize the streaming functionality of HOOPS Communicator via CaaS you need to request a streaming session and make one or more models accessible for streaming. The session data object returned can then be used to start the webviewer with. You don't have to initially pass any modelids to the <code>getStreamingSession</code> function. In that case specify &quot;_empty&quot; for the model to load. In a typical application the actual name of the model will be stored as part of your business logic alongside its id when the model was originally converted though you can retrieve all the relevant data of a model with the <code>getModelData</code> function.</p>
<pre class="prettyprint source"><code>/// In production this call should be performed server-side and the result should be passed to the client
let sessiondata = await caasClient.getStreamingSession({accessItems: [&quot;ID-OF-MODEL-TO-STREAM&quot;]});
let sessionid = sessiondata.sessionid;   // The session id is needed to add additional models to the session later

if (!sessiondata.ERROR) {
    viewer = new Communicator.WebViewer({
        containerId: &quot;mycontainer&quot;
        endpointUri: sessiondata.endpointUri,
        model: &quot;bnc.hsf&quot;
        rendererType: Communicator.RendererType.Client)
    });
}
</code></pre>
<h3>Adding additional models to a streaming session</h3>
<p>To add additional models to a streaming session you can use the <code>enableStreamAccess</code> function. This function takes an existing sessionid and an array of model ids.</p>
<pre class="prettyprint source"><code>// In production this call should be performed server-side
let saresult = await caasClient.enableStreamAccess(sessionid,[itemid1,itemid2]);

hwv.model.loadSubtreeFromModel(hwv.model.getRootNode(),&quot;model1&quot;);
</code></pre></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#createCustomImage">createCustomImage</a></li><li><a href="global.html#createEmptyModel">createEmptyModel</a></li><li><a href="global.html#deleteModel">deleteModel</a></li><li><a href="global.html#enableStreamAccess">enableStreamAccess</a></li><li><a href="global.html#getDownloadToken">getDownloadToken</a></li><li><a href="global.html#getFileByName">getFileByName</a></li><li><a href="global.html#getFileByType">getFileByType</a></li><li><a href="global.html#getInfo">getInfo</a></li><li><a href="global.html#getModelData">getModelData</a></li><li><a href="global.html#getModels">getModels</a></li><li><a href="global.html#getStatus">getStatus</a></li><li><a href="global.html#getStreamingSession">getStreamingSession</a></li><li><a href="global.html#getUploadToken">getUploadToken</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initializeWebViewer">initializeWebViewer</a></li><li><a href="global.html#reconvertModel">reconvertModel</a></li><li><a href="global.html#uploadModel">uploadModel</a></li><li><a href="global.html#uploadModelFromFile">uploadModelFromFile</a></li><li><a href="global.html#uploadModelFromFileInput">uploadModelFromFileInput</a></li><li><a href="global.html#uploadModelFromFiles">uploadModelFromFiles</a></li><li><a href="global.html#uploadModels">uploadModels</a></li><li><a href="global.html#waitUntilConverted">waitUntilConverted</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>